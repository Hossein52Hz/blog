+++
title = "ساختار داده های احتمالاتی Bloom filter"
description = ""
author = ""
date = 2018-05-22T02:06:49+04:30
tags = ["bloom filter", "ساختار داده های احتمالاتی" , "data structure" , "probabilistic data structures" ]
draft = true
+++

توجه: این پست در حال بروزرسانی هست. لطفا چند روز دیگه سر بزنید.

خب این بلوم فیلتر چیه و به چه دردی میخوره را من هم نمیدونستم تا اینکه توی مقاله ای برای کاهش مصرف حافظه و کاهش افزونگی داده های تبادل شده بین نودهای شبکه های DTN بهش برخوردم. و چون دیدم جالب بود گفتم اینجا منتشر کنم.
اگر سری به ویکی پدیا بزنید یک تعریف جالبی از ساختار داده های احتمالاتی میبینید که یک بخشی توضیح داده که از خطای مثبت کاذب و منفی استفاده می کنه.

داستان وقتی جالب تر میشه که به بخش زیر در ادامه توضیحات بلوم فیلتر بر میخوریم. و با تعریف زیر روبرو می شید:

فرض کنید می‌خواهیم وجود یک عنصری را در مجموعه جستجو کنیم، اگر داده ساختار به شما جواب داد که این عضو در مجموعه وجود دارد احتمال دارد که وجود نداشته باشد. اما اگر بگوید وجود ندارد، قطعاً درست هست. بر این اساس خطای مثبت داریم ولی خطای منفی امکان پذیر نمی‌باشد.

احتمالا شما هم مثل من گیچ شدید :) . با کمی تحقیق و پرس و جو و تبادل نظر نتیجه را میتونیم اینطور در نظر بگیریم: فرض کنید ما یک لیست داریم که فقط و فقط مشخصات داده هایی که وارد لیست میشن را مینویسیم دقت کنید ما در مورد داده های که خارج میشن چیزی نمی نویسیم. به این معنی که ممکنه یک داده ای وارد شده باشه و بعد هم خارج شده باشه و ما فقط زمان ورود اسمش را ثبت کردیم. فرض کنید متغیرهای X,U,A,H وارد شدند. حالا اگر یک نفر از ما سوال کنه که داده X داخل لیست هست یا نه ؟ ما چه جوابی میتونیم بدیم؟ درسته ما میتونیم بگیم X در لیست وجود داره و یک احتمال هم هست که متغیر X توی لیست نباشه و از لیست خارج شده باشه و از اونجایی که ما فقط و فقط لیست ورودی ها را یادداشت میکنیم این توضیح درست هست. توجه داشته باشید ما نمیریم داخل مجموعه ای که عنصرها داخلش ذخیره شدند جست و جو انجام بدیم، ما یک لیست ثبت نامی جداگانه داریم که فقط لیست ورودی ها را داخلش مینویسیم.

اما اگر دنبال متغیر Y بگردیم و نتیجه جست و جو به ما بگه که این متغیر در لیست نیست ما قطعا میتونیم بگیم که این متغیر وجود نداره چرا؟ چون اصلا وارد نشده هنوز .

خب با این مقدمه بریم سراغ معرفی ساختار داده های احتمالاتی و بلوم فیلتر

## Bloom filter

احتمالا میدونید که جدول درهم سازی(hash tables) چطور کار می کنه؟ اگر نمیدونید پیشنهاد میکنم یک سری به ویکی بزنید. وقتی شما یک داده جدید در یک آرایه یا لیست ساده وارد می کنید، index جایی که داده در آن قرار داده می شه از روی داده ای که داره تشخیص داده نمی شه. این به این معنی هست که ارتباط مستقیمی بین index و مقدار وجود ندارد. به عنوان نتیجه اگر شما نیاز داشته باشید که یک مقدار را در آرایه جست و جو کنید شما مجبورید که همه Index ها را جست و جو کنید تا داده مورد نظرتون را پیدا کنید. اکنون در جدول hash شما key یا index را توسط هش کردن مقدار value تشخیص می دید. بعد این مقدار را در این index از لیست قرار می دید. به این معنی که key از روی مقدار value تشخیص داده می شه و هر زمانی شما نیاز به بررسی اینکه آیا value موجود هست یا نه داشته باشید شما فقط مقدار value را hash‌می کنید و بعد بر اساس key جست وجو می کنید. این خیلی سریعتر هست و مرتبه الگوریتم نیز O(1) است که خب خیلی سریع‌تر از O(n) هست.

![image](/blog/images/hash table.png)

حالا بیاید در نظر بگیریم که یک لیست بزرگی از پسوردهای ضعیف وجود دارد و آن ها روی برخی از سرورهای ریموت ذخیره شده اند. امکان لود پسوردها بصورت فوری در حافظه memory/RAM به خاطر حجم پایین وجود ندارد. هر زمان یک کاربر پسورد خودش را وارد می کند شما میخواهید بررسی کنید که اگر پسورد ضعیف بود به کاربر یک هشدار بدهید برای تغییر پسوردش. چه کار میتونید بکنید؟ در نظر بگیرید که شما لیست پسوردهای ضعیف را دارید، شما می تونید این ها را در یک جدول hash یا چیزی مشابه ذخیره کنید و هر زمان که میخواهید بررسی کنید، شما می توانید چک کنید که آیا هیچ تشابهی وجود دارد یا نه. تشابه ممکن است سریع باشد اما هزینه جست و جوی آن روی دیسک یا روی شبکه در یک سرور ریموت ممکن است زیاد یا کند باشد. فراموش نکنید که شما شما این کار را برای هر پسوردی که توسط کاربر وارد میشه باید انجام بدید. چطور میشه هزینه این کار را کاهش داد ؟
بلوم فیلتر میتونه به ما کمک کنه. اما چطوری؟ بریم ببینیم بلوم فیلتر چطور کار میکنه.
طبق تعریف بلوم فیلتر میتونه یک مقدار را در حالت های “احتمال وجود آن در مجموعه هست” یا “به طور قطع در آن مجموعه نیست” بررسی کند. تفاوت ظریف بین احتمالا و قطعا نه در اینجا بسیار مهم می باشد. به خاطر این جمله “احتمالا در مجموعه هست “ هست که چرا این ساختار داده ها احتمالاتی نامیده می شوند. با استفاده از کلمات هوشمند بدین معنی هست که مثبت کاذب امکان پذیر هست اما منفی کاذب غیر ممکن هست. عجله نکنید، در ادامه نشون میدیم که دقیقا اینا یعنی چی.
بلوم فیلتر اساسا شامل یک بردار بیتی یا لیست بیتی(یک لیست شامل مقدار بیت فقط 0 یا 1) به طول m، با مقدار اولیه 0 مانند شکل زیر است:


![image](/blog/images/1.png)

برای اضافه کردن یک آیتم به بلوم فیلتر، ما آن را به k تابع هش مختلف می دهیم و مکان مقدارهای خروجی را برابر 1 قرار میدهیم. همونطور که میتونید ببینید در جدول هش ما از یک تابع هش تکی استفاده کردیم و به عنوان نتیجه فقط یک index تکی به عنوان خروجی داریم. اما در این مورد از بلوم فیلتر ما از تابع هش چندگانه استفاده می کنیم که خروجی چندگانه نیز خواهیم داشت.

![image](/blog/images/2.png)

همونطور که در تصویر بالا مشخص هست برای ورودی geeks ما سه تابع هش داریم و سه خروجی مختلف که مقدار 1 ,4,7 هست که ما آن ها را مشخص کردیم.

![image](/blog/images/3.png)

برای ورودی دیگری به نام nerd توابع هش به ما ۳ خروجی 3,4,5 را میدهد. شاید متوجه شده باشید که index شماره 4 قبلا علامت گذاری شده با کلمه geeks.  نگران نباشید این نکته جذابی هست و در ادامه متوجه آن می شویم. 
خب تا اینجا با بردار بیتی خودمان را با دو وردی پر کرده ایم. و حالا می تونیم بررسی کنیم که آیا مقدار مورد نظر ما داخل آن وجود دارد یا نه. اما چطوری؟ خیلی ساده هست. ما یک جدول هش ایجاد کردیم. ما ورودی مورد نظرمون که میخواهیم جست و جو کنیم را با سه تا تابع هش می کنیم و حاصل را بررسی می کنیم که کدام index ها میشه.

![image](/blog/images/4.png)

بنابراین جست و جو برای کلمه cat را انجام می دهیم که خروجی سه تابع هش برابر 1 ,3,7 هست که میتونیم ببینیم که مقدار هر سه تا خونه 1,3,7 برابر 1 هست که این به این معنی است که ما میتوانیم بگوییم “احتمالا کمله cat در لیست وارد شده باشد”. اما وارد نشده است!! پس این خطا از کجا هست؟
در واقع هیچ خطایی رخ نداده. این یک مورد از خطای مثبت کاذب است. بلوم فیلتر به ما می گوید که این نشان می دهد که شاید کلمه cat قبلا وارد شده بوده است زیرا همه خونه های index مربوط به خروجی سه تابع هش برابر 1 هست(حتی با داده های مختلف دیگر).
خب این کجاش مفید هست و بدرد میخوره؟ بیاید در نظر بگیریم اگر خروجی توابع هش برای کلمه cat برابر 1,6,7 می بود به جای 1,3,7. در این صورت چی می شد؟ ما می تونستیم ببینیم که Index مربوط به 6 برابر 0 هست. که به این معنی هست که با هیچ ورودی، قبلا این خونه علامتگذاری نشده. که به این معنی است که کلمه cat هیچوقت وارد نشده است. این نحوه کار بلوم فیلتر است که می تواند به ما بگوید “دقیقا”داده در لیست وجود ندارد.
خب به طور خلاصه:

* اگر ما برای یک مقدار جست و جو کردیم و نتیجه هر هش ای را پیدا کردیم که مقدار آن برابر 0 بود ما میتونیم با اطمینان بگوییم که در لیست وجود ندارد.

* اگر همه indexهای هش برابر 1 باشد آنگاه ممکن است مقدار جست و جو شده وجود داشته باشد.

خب بزارید برگردیم به مثال پسورد که ابتدا در موردش صحبت کردیم. اگر ما بررسی پسوردهای ضعیف را با این نوع از بلوم فیلتر پیاده سازی کنیم ما می توانیم ببینیم که ابتدا، ما بلوم فیلترمان را با یک لیست از پسوردها که به ما یک بردار بیتی می دهد که برخی از indexهای آن با 1مقدار دهی شده و مابقی با 0 مقدار دهی شده است. از آنجایی که اندازه بلوم فیلتر نمی تواند خیلی بزرگ باشد و یک اندازه ثابت دارد، این می تواند به راحتی در حافظه ذخیره شود حتی در صورت نیاز می تواند در سمت کلاینت ذخیره شود. به همین دلیل این است که چرا بلوم فیلتر بسیار space-efficient است. در حالی که یک جدول هش نیاز به داشتن اندازه دلخواه بر اساس داده های ورودی دارد، بلوم فیلترها می توانند با اندازه ثابت به خوبی کار کنند.

بنابراین هر بار که کاربر پسورد خود را وارد می کند ما آن را به توابع هش خود می دهیم و آن را در بردار بیتی بررسی می کنیم که وجود نداشته باشد. اگر پسورد به اندازه کافی قوی بود بلوم فیلتر به ما نشان می دهد که پسورد دقیقا در لیست پسورد های ضعیف نیست و نیازی نیست که ما کوئری سمت سرور بزنیم. اما اگر پسورد ضعیف بود و به ما جواب مثبت(ممکن است مثبت کاذب باشد) داده شود، ما یک درخواست سمت سرور برای بررسی لیست اصلی می کنیم.
همانطور که میبینید اغلب اوقات ما حتی نیاز به درخواست از سرور نداریم و یا از دیسک برای چک کردن لیست که این باعث بهبود قابل توجهی در سرعت نرم افزار می شود. در صورتی که بخواهیم بردار بیتی را در سمت سرویس گیرنده ذخیره کنیم، هنوز هم می توانیم آن را در حافظه سرور بارگزاری کنیم و حداقل برخی از زمان جست و جوی دیسک را ذخیره کنیم. همچنین در نظر بگیرید که اگر نرخ خطای مثبت بلوم فیلتر شما 1% باشد به این معنی است که در میان هزینه های مراجعه به سرور یا دیسک، تنها 1% از کوئری های ما با خطا مواجه خواهد شد و ۹۹درصد دیگر سمت سرور نخواهند رفت. بد نیست نه ؟

(نکته : به جای مراجعه به لیست بلندی از پسوردها و جست و جو داخلشون که از مرتبه n یا دیگر مرتبه ها است ما از روی پسوردها یک بردار بیتی درست میکنیم و کلمه مورد نظر را هش میکنیم مثلا ۳ تا خروجی میده فقط ۳تا خونه خروجی را بررسی می کنیم یعنی O(k) میشه جست و جوی ما)

![image](/blog/images/5.png)

## عملیات های بلوم فیلتر

یک بلوم فیلتر ساده از دو عملیات test و add پشتیبانی می کند. Test برای چک کردن اینکه آیا یک عنصر در مجموعه وجود دارد یا نه. add هم برای اضافه کردن یک عنصر به مجموعه. 

به نظرتون امکان حذف کردن یک ایتم از بلوم فیلتر وجود دارد؟ قبل از ادامه دادن یکم روی جواب تون فکر کنید.

قبل از جواب دادن به سوال بالا بیاید یک مثال بصورت عملی بررسی کنیم. فرض کنید در بردار بیتی دو کلمه geeks و nerd را اضافه کردیم:

![image](/blog/images/6.png)

![image](/blog/images/7.png)

حالا ما میخواهیم عنصر geeks را از بلوم فیلتر حذف کنیم. بنابراین اگر ما 1,4,7 را از بردار بیتی حذف کنیم که قبلا توسط geeks علامت گذاری شده بودند، و ما مقدارشونا به 0 تغییر بدیم چه اتفاقی می افته ؟

به سادگی میتونید ببینید که اگر ما در ادامه کلمه nerd را جست و جو کنیم همانطور که میبینید Index شماره 4 برابر 0 هست و این به ما میگوید که دقیقا nerd در لیست وجود ندارد در حالی که اشتباه است. این بدین معنی است که امکان حذف وجود ندارد. 

پس راه حل چیه؟ در واقع توی بلوم فیلتر ساده چنین امکان وجود نداره. اما اگر واقعا به چنین چیزی نیاز دارید می تونید از یک نسخه تغییر یافته بلوم فیلتر به نام Counting bloom filter استفاده کنید. ایده ساده است. به جای مرتب سازی یک بیت تکی از مقدارها، ما یک مقدار integer را ذخیره می کنیم و بردار بیتی ما بردار integer خواهد بود. قابلیت حذف کردن باعث افزایش اندازه و هزینه ما خواهد شد. در این حالت به جای علامت گذاری یک مقدار بیت با 1 هنگام ورود داده، ما مقدار integer را به مقدار 1 افزایش می دهیم. برای بررسی اینکه یک عنصر موجود هست یا نه کافی هست که عنصر را هش کنیم و خانه هایی را که بررسی میکنیم مقدارشون بیشتر از 0 باشه. 

## اندازه Bloom filter و تعداد توابع Hash 

شاید به این فکر کرده باشید که اگر اندازه بلوم فیلتر کوچک در نظر گرفته بشه ممکنه سریع همه خونه های آن برابر 1 بشه و بعد از این هر کلمه ای چه در لیست باشه چه نباشه را بررسی کنیم جواب مثبت برگردانده بشه. بنابراین اندازه بلوم فیلتر خیلی مهم است. در اینجا اگر اندازه بلوم فیلتر بزرگ انتخاب شود ما جواب های مثبت کاذب کمتری داریم و اگر اندازه کوچک باشد ما جواب های مثبت کاذب بیشتری خواهیم داشت. اینجا یک موضوع جدید خواهیم داشت با عنوان نرخ خطای مثبت کاذب.
پارامتر مهم دیگر این است که چه تعداد تابع هش نیاز داریم؟ 

طبق مقاله ارائه شده توسط که نتیجه آن در شکل زیر نشان داده شده می تونید ببینید که اندازه بلوم فیلتر و تعداد توابع هش به صورت مناسب چقدر هست:

![image](/blog/images/Abishek article.png)

در نمودار بالا با افزایش تعداد تابع هش k نرخ خطا p کاهش پیدا می کند. ما می توانیم نرخ خطای کاذب مثبت P را محاسبه کنیم. بر اساس اندازه فیلتر m و تعداد تابع هش k و تعداد عنصر ورودی هم برابر n می باشد. 

![image](/blog/images/formula1.png)

اگر به ریاضیات علاقه ای ندارید نگران نباشید :). در واقع ما فقط نیاز داریم که مقدار m و k را مشخص کنیم. اگر نرخ خطای مثبت کاذب ما برابر p باشد و تعداد ورودی ها n باشد ما می تونیم از فرمول های زیر برای محاسبه پارامترهامون استفاده کنیم:

![image](/blog/images/formula2.png)

نکته دیگه که باید توجه کنید این هست که هدف استفاده از بلوم فیلتر جست و جوی سریعتر هست، ما نمی توانیم از توابع هش با سرعت پایین استفاده کنیم. بنابراین توابع هش رمزنگاری Sha-1 و MD5 انتخاب خوبی برای بلوم فیلترها نیستند. بنابراین انتخاب های بهتر برای توابع هش سریعتر پیاده سازی شدن که می تونید ازشون استفاده کنید. مثل : 
murmur       fnv       HashMix

## کاربردها

بلوم فیلتر برای بررسی عضو داخل یک مجموعه است. مثال ساده بلوم فیلتر برای کاهش هزینه مراجعه به دیسک یا شبکه برای کلیدهای ناموجود است. همونطور که ما میتونیم ببینیم بلوم فیلترها می توانند یک کلید را در O(k) جست و جو کنند که k تعداد تابع هش هست. این بسیار سریعتر هست که کلید ناموجود را جست و جو کنیم. اگر عنصر در بلوم فیلتر نباشد پس ما نیازی به جست و جوی پر هزینه نداریم. از طرف دیگر اگر عنصر در بلوم فیلتر موجود باشد ما جست و جو را انجام میدیم و میتونیم انتظار داشته باشیم که در برخی موارد ما نرخ خطای مثبت کاذب(false positive rate) داشته باشیم. و عنصر موجود نباشد.

## مثال های استفاده از بلوم فیلتر:

* برای هشدار به کاربران در مورد ضعیف بودن پسورد که در بالا توضیح داده شد.

* برای جلوگیری از دسترسی کاربران به سایت های مخرب

* برای بررسی اینکه چه کاربرانی قبلا از سایت شما بازدید کردند بر اساس IP هاشون.

* برای بررسی اینکه چه تعداد از کاربران محتوای سایت شما را خوانده اند